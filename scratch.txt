from dash import (
    html, dcc, callback, Input, Output, State,
    ALL, MATCH, ctx
)
import dash_bootstrap_components as dbc

# ===============================
# Symbols
# ===============================
CHECK = "✓"
INDET = "−"
EMPTY = ""

# ===============================
# Tree construction (deterministic)
# ===============================
def build_tree(paths):
    root = {}
    for p in sorted(paths):
        cur = root
        for part in p.split("::"):
            cur = cur.setdefault(part, {})
    return root


def to_nodes(tree, parent=""):
    out = []
    for k in sorted(tree.keys()):
        path = f"{parent}::{k}" if parent else k
        out.append({
            "label": k,
            "path": path,
            "children": to_nodes(tree[k], path)
        })
    return out


# ===============================
# Component
# ===============================
def tree_dropdown(id, paths, button_label="Filter Books"):

    tree = to_nodes(build_tree(paths))
    leaf_paths = set(paths)

    # ---------- helpers ----------
    def checkbox(path):
        return html.Span(
            id={"cmp": id, "type": "chk", "path": path},
            n_clicks=0,
            children=EMPTY,
            style={
                "width": "16px",
                "height": "16px",
                "border": "1px solid #555",
                "display": "inline-flex",
                "alignItems": "center",
                "justifyContent": "center",
                "cursor": "pointer",
                "fontWeight": "bold",
                "marginRight": "6px",
                "userSelect": "none",
            },
        )

    def render_node(node, level=0):
        p = node["path"]
        indent = level * 18

        row = html.Div(
            [
                checkbox(p),
                html.Span(node["label"]),
            ],
            style={"marginLeft": f"{indent}px", "display": "flex"},
        )

        if not node["children"]:
            return row

        return html.Div(
            [
                row,
                html.Div(
                    [render_node(c, level + 1) for c in node["children"]],
                    id={"cmp": id, "type": "children", "path": p},
                ),
            ]
        )

    layout = html.Div(
        [
            # ---------- stores ----------
            dcc.Store(id={"cmp": id, "type": "checked"}, data={}),
            dcc.Store(id={"cmp": id, "type": "paths"}, data=paths),
            dcc.Store(id={"cmp": id, "type": "leafs"}, data=list(leaf_paths)),

            # ---------- toggle ----------
            dbc.Button(
                button_label,
                id={"cmp": id, "type": "toggle"},
                color="secondary",
                size="sm",
            ),

            dbc.Collapse(
                html.Div(
                    [render_node(n) for n in tree],
                    id={"cmp": id, "type": "tree"},
                    style={
                        "border": "1px solid #ccc",
                        "padding": "6px",
                        "marginTop": "6px",
                        "maxHeight": "260px",
                        "overflowY": "auto",
                        "background": "white",
                    },
                ),
                id={"cmp": id, "type": "collapse"},
                is_open=False,
            ),

            html.Pre(
                id={"cmp": id, "type": "selected"},
                style={
                    "marginTop": "8px",
                    "fontSize": "12px",
                    "background": "#fafafa",
                    "padding": "6px",
                },
            ),
        ]
    )

    # ===============================
    # Collapse toggle
    # ===============================
    @callback(
        Output({"cmp": id, "type": "collapse"}, "is_open"),
        Input({"cmp": id, "type": "toggle"}, "n_clicks"),
        State({"cmp": id, "type": "collapse"}, "is_open"),
        prevent_initial_call=True,
    )
    def toggle(_, open_):
        return not open_

    # ===============================
    # Tri-state logic (SAFE)
    # ===============================
    @callback(
        Output({"cmp": id, "type": "chk", "path": ALL}, "children"),
        Output({"cmp": id, "type": "checked"}, "data"),
        Input({"cmp": id, "type": "chk", "path": ALL}, "n_clicks"),
        State({"cmp": id, "type": "chk", "path": ALL}, "id"),
        State({"cmp": id, "type": "checked"}, "data"),
        State({"cmp": id, "type": "leafs"}, "data"),
        prevent_initial_call=True,
    )
    def toggle_check(_, ids, checked, leafs):

        checked = dict(checked or {})
        ids = ids or []

        trigger = ctx.triggered_id
        clicked = trigger.get("path") if isinstance(trigger, dict) else None

        # ---------- helpers ----------
        def descendants(p):
            pref = p + "::"
            return [x for x in leafs if x.startswith(pref)]

        def state(p):
            if p in leafs:
                return CHECK if checked.get(p, False) else EMPTY
            kids = descendants(p)
            vals = [checked.get(k, False) for k in kids]
            if vals and all(vals):
                return CHECK
            if any(vals):
                return INDET
            return EMPTY

        # ---------- no click ----------
        if clicked is None:
            return [state(i["path"]) for i in ids], checked

        # ---------- leaf ----------
        if clicked in leafs:
            checked[clicked] = not checked.get(clicked, False)

        # ---------- folder ----------
        else:
            kids = descendants(clicked)
            new_val = state(clicked) != CHECK
            for k in kids:
                checked[k] = new_val

        return [state(i["path"]) for i in ids], checked

    # ===============================
    # Show selected leaves
    # ===============================
    @callback(
        Output({"cmp": id, "type": "selected"}, "children"),
        Input({"cmp": id, "type": "checked"}, "data"),
        State({"cmp": id, "type": "leafs"}, "data"),
    )
    def show_selected(checked, leafs):
        checked = checked or {}
        sel = [p for p in leafs if checked.get(p)]
        return "\n".join(sel)

    return layout
